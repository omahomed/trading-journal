"""
simulate_strategy_trades.py

Purpose:
- Load historical stock price data from CSV (generated by stock_scraper.py)
- Apply a simple technical strategy:
    - Buy when Low > EMA21 for 3+ days followed by an up day
    - Sell when Close < 0.998 * EMA21
- Simulate trades using a starting balance of $1,000 on a user-defined start date
- Track compounding performance by reinvesting entire balance each trade
- Track additional metrics: Keltner Channel upper bands, max high since buy, % above sell threshold
- Export:
    1. Each ticker's full strategy data and trade log into its own Excel file
    2. One-row summary per ticker into a master summary Excel file
"""
import pandas as pd
import warnings
import os

# === Setup ===
warnings.simplefilter(action="ignore", category=FutureWarning)
os.makedirs("output", exist_ok=True)

# === User Configuration ===
tickers = ["HOOD"]
starting_balance = 67000
start_date = "2020-04-01"

# === Summary Collector ===
summaries = []

# === Loop through tickers ===
for ticker in tickers:
    input_file = f"output/{ticker}_price_data.csv"
    output_file = f"output/{ticker}_strategy_results.xlsx"

    # Step 1: Load and filter data
    try:
        df = pd.read_csv(input_file)
    except FileNotFoundError:
        print(f"âš ï¸ File not found: {input_file}. Skipping {ticker}.")
        continue

    df["Date"] = pd.to_datetime(df["Date"])
    df.set_index("Date", inplace=True)
    df = df[df.index >= start_date]

    for col in ["Open", "High", "Low", "Close"]:
        df[col] = pd.to_numeric(df[col], errors="coerce")
    df.dropna(subset=["Open", "High", "Low", "Close"], inplace=True)

    # Step 2: Compute indicators
    df["EMA21"] = df["Close"].ewm(span=21, adjust=False).mean()
    df["sell_threshold"] = df["EMA21"] * 0.998
    df["low_above_ema"] = df["Low"] > df["EMA21"]
    df["up_day"] = df["Close"] > df["Close"].shift(1)

    # Keltner Channel Upper Bands
    tr = df[["High", "Low", "Close"]].copy()
    tr["prev_close"] = tr["Close"].shift(1)
    tr["tr"] = tr[["High", "prev_close"]].max(axis=1) - tr[["Low", "prev_close"]].min(axis=1)
    df["RangeMA"] = tr["tr"].rolling(window=10).mean()
    df["Upper_2ATR"] = df["EMA21"] + 2 * df["RangeMA"]
    df["Upper_3ATR"] = df["EMA21"] + 3 * df["RangeMA"]
    df["Upper_4ATR"] = df["EMA21"] + 4 * df["RangeMA"]

    # New: Distance of daily high vs ATR bands (in %)
    df["pct_high_vs_3ATR"] = ((df["High"] - df["Upper_3ATR"]) / df["Upper_3ATR"]) * 100
    df["pct_high_vs_4ATR"] = ((df["High"] - df["Upper_4ATR"]) / df["Upper_4ATR"]) * 100

    # Initialize signal tracking columns
    df["signal"] = 0
    df["max_high_since_buy"] = None
    df["pct_above_sell_threshold"] = None

    # Step 3: Signal Logic
    streak = 0
    in_wait_mode = False
    position_open = False
    last_buy_index = None

    for i in range(2, len(df)):
        if position_open:
            # Sell condition
            if df.iloc[i]["Close"] < df.iloc[i]["sell_threshold"]:
                df.at[df.index[i], "signal"] = -1
                position_open = False
                in_wait_mode = False

                if last_buy_index is not None:
                    max_high = df.loc[df.index[last_buy_index]:df.index[i], "High"].max()
                    df.at[df.index[i], "max_high_since_buy"] = round(max_high, 2)
                    pct = ((max_high - df.iloc[i]["sell_threshold"]) / df.iloc[i]["sell_threshold"]) * 100
                    df.at[df.index[i], "pct_above_sell_threshold"] = round(pct, 2)

                streak = 0
                continue

        # Track streak of Low > EMA21
        if df.iloc[i]["low_above_ema"]:
            streak += 1
        elif df.iloc[i]["Close"] < df.iloc[i]["EMA21"]:
            streak = 0
            in_wait_mode = False

        # Buy condition
        if streak >= 3 and not position_open:
            if df.iloc[i]["up_day"]:
                df.at[df.index[i], "signal"] = 1
                position_open = True
                last_buy_index = i
                streak = 0
                in_wait_mode = False
            else:
                in_wait_mode = True

        elif in_wait_mode and df.iloc[i]["up_day"] and df.iloc[i]["low_above_ema"] and not position_open:
            df.at[df.index[i], "signal"] = 1
            position_open = True
            last_buy_index = i
            streak = 0
            in_wait_mode = False

        elif not df.iloc[i]["low_above_ema"] and df.iloc[i]["Close"] < df.iloc[i]["EMA21"]:
            streak = 0
            in_wait_mode = False

    # Step 4: Simulate Trades
    balance = starting_balance
    buy_price = None
    buy_date = None
    shares = None
    trade_count = 0
    final_status = "Fully Closed"
    trades = []

    for i in range(len(df)):
        row = df.iloc[i]
        date = df.index[i]
        signal = row["signal"]

        if signal == 1:
            # Buy
            buy_price = row["Close"]
            buy_date = date
            shares = int(balance // buy_price)
            invested = shares * buy_price
            start_balance_snapshot = balance
            balance = round(balance - invested, 2)
            trade_count += 1

        elif signal == -1 and buy_price is not None:
            # Sell
            sell_price = row["Close"]
            proceeds = round(shares * sell_price, 2)
            balance = round(balance + proceeds, 2)

            trades.append({
                "Buy Date": buy_date.date(),
                "Buy Price": round(buy_price, 2),
                "Shares": shares,
                "Sell Date": date.date(),
                "Sell Price": round(sell_price, 2),
                "Starting Balance": round(start_balance_snapshot, 2),
                "Cash After Trade": balance
            })

            buy_price = None
            buy_date = None
            shares = None
            trade_count += 1

    # Handle open position at end of data
    if buy_price is not None:
        final_status = "Still in Position"
        last_close = df.iloc[-1]["Close"]
        proceeds = round(shares * last_close, 2)
        balance = round(balance + proceeds, 2)

        trades.append({
            "Buy Date": buy_date.date(),
            "Buy Price": round(buy_price, 2),
            "Shares": shares,
            "Sell Date": df.index[-1].date(),
            "Sell Price": round(last_close, 2),
            "Starting Balance": round(start_balance_snapshot, 2),
            "Cash After Trade": balance,
            "Note": "Still in position"
        })
        trade_count += 1

    # Step 5: Prepare Output
    df_output = df[[
        "Open", "High", "Low", "Close", "EMA21", "sell_threshold",
        "low_above_ema", "up_day", "signal", "max_high_since_buy",
        "pct_above_sell_threshold", "Upper_2ATR", "Upper_3ATR", "Upper_4ATR",
        "pct_high_vs_3ATR", "pct_high_vs_4ATR"
    ]].round(2)

    percent_gain = round(((balance - starting_balance) / starting_balance) * 100, 2)

    summary_row = {
        "Ticker": ticker,
        "Start Date": pd.to_datetime(start_date).date(),
        "End Date": df.index[-1].date(),
        "Starting Balance": starting_balance,
        "Final Balance": round(balance, 2),
        "Percent Gain": percent_gain,
        "Total Trades": trade_count,
        "Status": final_status
    }

    summaries.append(summary_row)

    # Step 6: Save Excel file for this ticker
    with pd.ExcelWriter(output_file, engine="openpyxl") as writer:
        df_output.to_excel(writer, sheet_name="Strategy", index=True)
        pd.DataFrame(trades).to_excel(writer, sheet_name="Trades", index=False)
        pd.DataFrame([summary_row]).to_excel(writer, sheet_name="Summary", index=False)

    print(f"âœ… {ticker} strategy complete. Saved to: {output_file}")

# Step 7: Save master summary file
summary_df = pd.DataFrame(summaries)
summary_df.to_excel("output/simulation_summary_selected.xlsx", index=False)
print("\nðŸ“Š Master summary saved to: output/simulation_summary_selected.xlsx")