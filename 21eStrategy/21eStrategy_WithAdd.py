"""
21eStrategy_with_add.py - VERSION 2.1 - FIXED ADD EXECUTION LOGIC

CHANGELOG v2.1:
- Fixed: Add execution now checks Day 2 OPEN (not Low) against trigger
- Confirmed: All other logic remains correct (sell trigger applies to entire position)

CHANGELOG v2.0:
- Fixed: Add triggers now use SIGNAL ticker (IXIC) Low, not TRADE ticker (TQQQ)
- Fixed: Removed cash balance restriction - allows margin up to 150%
- Added: "Cash After Add" column in Add Details sheet
- Confirmed: All 9 adds executing correctly in backtest

Purpose:
- Load historical stock price data from CSV (generated by stock_scraper.py)
- Apply the 21 EMA strategy WITH ADDING logic:
    - Buy when Low > EMA21 for 3+ days followed by an up day
    - Sell when Close < EMA21 (sets trigger), then subsequent Low violation executes sell
    - Reset sell trigger if Close goes back above EMA21 before violation
    - 0.2% buffer added to sell trigger (trigger = Low * 0.998)
    - ADD 20% MORE SHARES when:
        * Original position is >25% profit (based on TQQQ price)
        * Last add (if any) is >5% profit (based on TQQQ price)
        * IXIC Close < EMA21 (triggers Day 1)
        * Day 2: IXIC Open >= (Day 1 IXIC Low * 0.998)
        * Execute add at Day 2 TQQQ Open price
        * Uses MARGIN - no cash restriction
- Simulate trades using a starting balance on a user-defined start/end date
- Track compounding performance by reinvesting entire balance each trade
- Export detailed Excel files with trade logs and strategy data
"""
import pandas as pd
import warnings
import os

print("="*60)
print("21 EMA STRATEGY WITH ADDING - VERSION 2.1")
print("="*60)

# === Setup ===
warnings.simplefilter(action="ignore", category=FutureWarning)
os.makedirs("output", exist_ok=True)

# === User Configuration ===
# Format: [("signal_ticker", "trade_ticker"), ...]
# For NASDAQ/IXIC: use "^IXIC" (the ^ will be removed when looking for the file)
# For same ticker strategy: ("NVDA", "NVDA")
# For cross-ticker strategy: ("^IXIC", "TQQQ")
ticker_pairs = [("^IXIC", "TQQQ")]  # CHANGE THIS to test different pairs
starting_balance = 83000  # CHANGE THIS for different starting capital
start_date = "2009-06-25"  # TQQQ inception date - CHANGE THIS for different test periods
end_date = "2025-12-31"  # CHANGE THIS to match your data range

# === Summary Collector ===
summaries = []

# === Loop through ticker pairs ===
for signal_ticker, trade_ticker in ticker_pairs:
    # Remove ^ for file names (IXIC_price_data.csv not ^IXIC_price_data.csv)
    signal_file = f"output/{signal_ticker.replace('^', '')}_price_data.csv"
    trade_file = f"output/{trade_ticker.replace('^', '')}_price_data.csv"
    output_file = f"output/{signal_ticker.replace('^', '')}_{trade_ticker.replace('^', '')}_21eStrategy_with_add.xlsx"

    print(f"\n{'='*60}")
    print(f"Processing: {signal_ticker} -> {trade_ticker}")
    print(f"{'='*60}")

    # Step 1: Load signal ticker data
    try:
        signal_df = pd.read_csv(signal_file)
        print(f"‚úÖ Loaded signal file: {signal_file}")
    except FileNotFoundError:
        print(f"‚ùå Signal file not found: {signal_file}")
        print(f"   Looking for file with this exact name in the output folder.")
        continue

    # Step 2: Load trade ticker data  
    try:
        trade_df = pd.read_csv(trade_file)
        print(f"‚úÖ Loaded trade file: {trade_file}")
    except FileNotFoundError:
        print(f"‚ùå Trade file not found: {trade_file}")
        print(f"   Looking for file with this exact name in the output folder.")
        continue

    # Process signal ticker data
    signal_df["Date"] = pd.to_datetime(signal_df["Date"])
    signal_df.set_index("Date", inplace=True)
    
    # Show available date range
    print(f"\nüìÖ {signal_ticker} available data: {signal_df.index.min().date()} to {signal_df.index.max().date()}")
    print(f"   Requested test period: {start_date} to {end_date}")
    
    signal_df = signal_df[(signal_df.index >= start_date) & (signal_df.index <= end_date)]
    
    if len(signal_df) == 0:
        print(f"‚ùå No {signal_ticker} data in requested date range!")
        continue

    for col in ["Open", "High", "Low", "Close"]:
        signal_df[col] = pd.to_numeric(signal_df[col], errors="coerce")
    signal_df.dropna(subset=["Open", "High", "Low", "Close"], inplace=True)
    
    if len(signal_df) == 0:
        print(f"‚ùå No valid {signal_ticker} data after cleaning!")
        continue

    # Process trade ticker data
    trade_df["Date"] = pd.to_datetime(trade_df["Date"])
    trade_df.set_index("Date", inplace=True)
    
    print(f"üìÖ {trade_ticker} available data: {trade_df.index.min().date()} to {trade_df.index.max().date()}")
    
    trade_df = trade_df[(trade_df.index >= start_date) & (trade_df.index <= end_date)]
    
    if len(trade_df) == 0:
        print(f"‚ùå No {trade_ticker} data in requested date range!")
        continue

    for col in ["Open", "High", "Low", "Close"]:
        trade_df[col] = pd.to_numeric(trade_df[col], errors="coerce")
    trade_df.dropna(subset=["Open", "High", "Low", "Close"], inplace=True)
    
    if len(trade_df) == 0:
        print(f"‚ùå No valid {trade_ticker} data after cleaning!")
        continue

    # Create a map of trade ticker prices by date for quick lookup
    trade_prices = {}
    for date, row in trade_df.iterrows():
        trade_prices[date] = {
            'Open': row['Open'],
            'High': row['High'], 
            'Low': row['Low'],
            'Close': row['Close']
        }

    print(f"\nüìä Processing Strategy:")
    print(f"   Signal data: {len(signal_df)} rows from {signal_df.index[0].date()} to {signal_df.index[-1].date()}")
    print(f"   Trade data:  {len(trade_df)} rows from {trade_df.index[0].date()} to {trade_df.index[-1].date()}")

    # Step 3: Compute indicators on SIGNAL ticker
    signal_df["EMA21"] = signal_df["Close"].ewm(span=21, adjust=False).mean()
    signal_df["sell_threshold"] = signal_df["EMA21"] * 0.998
    signal_df["low_above_ema"] = signal_df["Low"] > signal_df["EMA21"]
    signal_df["up_day"] = signal_df["Close"] > signal_df["Close"].shift(1)

    # Keltner Channel Upper Bands (on signal ticker)
    tr = signal_df[["High", "Low", "Close"]].copy()
    tr["prev_close"] = tr["Close"].shift(1)
    tr["tr"] = tr[["High", "prev_close"]].max(axis=1) - tr[["Low", "prev_close"]].min(axis=1)
    signal_df["RangeMA"] = tr["tr"].rolling(window=10).mean()
    signal_df["Upper_2ATR"] = signal_df["EMA21"] + 2 * signal_df["RangeMA"]
    signal_df["Upper_3ATR"] = signal_df["EMA21"] + 3 * signal_df["RangeMA"]
    signal_df["Upper_4ATR"] = signal_df["EMA21"] + 4 * signal_df["RangeMA"]

    # Distance of daily high vs ATR bands (in %)
    signal_df["pct_high_vs_3ATR"] = ((signal_df["High"] - signal_df["Upper_3ATR"]) / signal_df["Upper_3ATR"]) * 100
    signal_df["pct_high_vs_4ATR"] = ((signal_df["High"] - signal_df["Upper_4ATR"]) / signal_df["Upper_4ATR"]) * 100

    # Initialize signal tracking columns
    signal_df["signal"] = 0  # 1=buy, -1=sell, 2=add
    signal_df["trade_ticker_price"] = None
    signal_df["max_high_since_buy"] = None
    signal_df["pct_above_sell_threshold"] = None
    signal_df["sell_trigger_level"] = None
    signal_df["add_trigger_level"] = None
    signal_df["position_profit_pct"] = None
    signal_df["last_add_profit_pct"] = None
    signal_df["add_check_day"] = ""  # Track Day 1/Day 2 for debugging

    # Step 4: Strategy Signal Logic with ADDING
    streak = 0
    in_wait_mode = False
    position_open = False
    last_buy_index = None
    sell_triggered = False
    sell_trigger_low = None
    
    # Adding logic tracking
    original_buy_price = None
    last_add_price = None
    prev_day_add_trigger = None  # Store the add trigger from previous day

    for i in range(2, len(signal_df)):
        current_date = signal_df.index[i]
        
        if current_date not in trade_prices:
            continue
            
        trade_close = trade_prices[current_date]['Close']
        trade_open = trade_prices[current_date]['Open']
        trade_low = trade_prices[current_date]['Low']
        signal_df.at[current_date, "trade_ticker_price"] = trade_close

        if position_open:
            # Calculate current profit percentages
            if original_buy_price is not None:
                position_profit = ((trade_close - original_buy_price) / original_buy_price) * 100
                signal_df.at[current_date, "position_profit_pct"] = round(position_profit, 2)
            
            if last_add_price is not None:
                last_add_profit = ((trade_close - last_add_price) / last_add_price) * 100
                signal_df.at[current_date, "last_add_profit_pct"] = round(last_add_profit, 2)

            # CHECK FOR ADDS FIRST (Day 2 execution from previous Day 1 trigger)
            if prev_day_add_trigger is not None:
                signal_df.at[current_date, "add_check_day"] = "Day 2 Check"
                # Day 2: Check if today's SIGNAL ticker OPEN is above yesterday's Day 1 trigger
                signal_open = signal_df.iloc[i]["Open"]
                if signal_open >= prev_day_add_trigger:
                    # Execute ADD at today's TRADE ticker Open
                    signal_df.at[current_date, "signal"] = 2  # 2 = add signal
                    last_add_price = trade_open  # Track TRADE ticker price for future 5% check
                    print(f"   ‚úÖ ADD executed on {current_date.date()} at TQQQ ${trade_open:.2f} (IXIC Open: ${signal_open:.2f} >= Trigger: ${prev_day_add_trigger:.2f})")
                else:
                    print(f"   ‚ùå ADD skipped on {current_date.date()} - Open below trigger (IXIC Open: ${signal_open:.2f} < Trigger: ${prev_day_add_trigger:.2f})")
                
                # Clear the trigger regardless of execution
                prev_day_add_trigger = None

            # SELL LOGIC (check before setting new add triggers)
            if not sell_triggered and signal_df.iloc[i]["Close"] < signal_df.iloc[i]["EMA21"]:
                sell_triggered = True
                sell_trigger_low = signal_df.iloc[i]["Low"] * 0.998  # 0.2% buffer
                signal_df.at[current_date, "sell_trigger_level"] = round(sell_trigger_low, 2)
                
                # ALSO check if this triggers ADD logic (Day 1 setup)
                # Check profit conditions
                position_profit_check = ((trade_close - original_buy_price) / original_buy_price) * 100
                last_add_profit_check = 100  # Default to passing if no previous add
                if last_add_price is not None:
                    last_add_profit_check = ((trade_close - last_add_price) / last_add_price) * 100
                
                print(f"   üìä {current_date.date()} Close < EMA21 detected:")
                print(f"      Position profit: {position_profit_check:.2f}% (need >25%)")
                print(f"      Last add profit: {last_add_profit_check:.2f}% (need >5%)")
                
                # If profit conditions met, flag for potential add on NEXT day
                if position_profit_check > 25 and last_add_profit_check > 5:
                    prev_day_add_trigger = signal_df.iloc[i]["Low"] * 0.998  # Use SIGNAL ticker's Low with 0.2% buffer
                    signal_df.at[current_date, "add_trigger_level"] = round(prev_day_add_trigger, 2)
                    signal_df.at[current_date, "add_check_day"] = "Day 1 Setup"
                    print(f"      ‚úÖ Day 1 add trigger set: IXIC ${prev_day_add_trigger:.2f}")
                else:
                    print(f"      ‚ùå Profit conditions not met for add")
                
            elif sell_triggered and signal_df.iloc[i]["Close"] > signal_df.iloc[i]["EMA21"]:
                # Reset sell trigger (Close went back above EMA21)
                sell_triggered = False
                sell_trigger_low = None
                signal_df.at[current_date, "sell_trigger_level"] = None
                # Also clear any pending add trigger
                prev_day_add_trigger = None
                
            elif sell_triggered and signal_df.iloc[i]["Low"] < sell_trigger_low:
                # Execute sell - EXIT entire position
                signal_df.at[signal_df.index[i], "signal"] = -1
                position_open = False
                sell_triggered = False
                sell_trigger_low = None
                in_wait_mode = False
                
                # Reset add tracking
                prev_day_add_trigger = None
                original_buy_price = None
                last_add_price = None

                if last_buy_index is not None:
                    max_high = signal_df.loc[signal_df.index[last_buy_index]:signal_df.index[i], "High"].max()
                    signal_df.at[signal_df.index[i], "max_high_since_buy"] = round(max_high, 2)
                    pct = ((max_high - signal_df.iloc[i]["sell_threshold"]) / signal_df.iloc[i]["sell_threshold"]) * 100
                    signal_df.at[signal_df.index[i], "pct_above_sell_threshold"] = round(pct, 2)

                streak = 0
                continue

        # BUY LOGIC (same as original)
        if signal_df.iloc[i]["low_above_ema"]:
            streak += 1
        elif signal_df.iloc[i]["Close"] < signal_df.iloc[i]["EMA21"]:
            streak = 0
            in_wait_mode = False

        if streak >= 3 and not position_open:
            if signal_df.iloc[i]["up_day"]:
                signal_df.at[signal_df.index[i], "signal"] = 1
                position_open = True
                last_buy_index = i
                original_buy_price = trade_close  # Track original entry price
                last_add_price = None  # Reset add tracking
                prev_day_add_trigger = None
                streak = 0
                in_wait_mode = False
                sell_triggered = False
                sell_trigger_low = None
                print(f"   üü¢ BUY signal on {current_date.date()} at ${trade_close:.2f}")
            else:
                in_wait_mode = True

        elif in_wait_mode and signal_df.iloc[i]["up_day"] and signal_df.iloc[i]["low_above_ema"] and not position_open:
            signal_df.at[signal_df.index[i], "signal"] = 1
            position_open = True
            last_buy_index = i
            original_buy_price = trade_close  # Track original entry price
            last_add_price = None  # Reset add tracking
            prev_day_add_trigger = None
            streak = 0
            in_wait_mode = False
            sell_triggered = False
            sell_trigger_low = None
            print(f"   üü¢ BUY signal on {current_date.date()} at ${trade_close:.2f}")

        elif not signal_df.iloc[i]["low_above_ema"] and signal_df.iloc[i]["Close"] < signal_df.iloc[i]["EMA21"]:
            streak = 0
            in_wait_mode = False

    # Step 5: Simulate Trades with ADDING (MARGIN ENABLED)
    balance = starting_balance
    buy_price = None
    buy_date = None
    shares = None
    trade_count = 0
    final_status = "Fully Closed"
    trades = []
    adds = []  # Track all adds for detailed logging

    for i in range(len(signal_df)):
        row = signal_df.iloc[i]
        date = signal_df.index[i]
        signal = row["signal"]
        
        if date not in trade_prices:
            continue
            
        trade_close_price = trade_prices[date]['Close']
        trade_open_price = trade_prices[date]['Open']

        if signal == 1:  # BUY
            buy_price = trade_close_price
            buy_date = date
            shares = int(balance // buy_price)
            invested = shares * buy_price
            start_balance_snapshot = balance
            balance = round(balance - invested, 2)
            trade_count += 1
            adds = []  # Reset adds tracking for new trade

        elif signal == 2:  # ADD 20% more shares (MARGIN ALLOWED)
            add_shares = int(shares * 0.20)
            add_price = trade_open_price
            add_invested = add_shares * add_price
            # Allow margin - no cash balance check
            balance = round(balance - add_invested, 2)
            shares += add_shares  # Increase total shares
            adds.append({
                "Date": date.date(),
                "Price": round(add_price, 2),
                "Shares": add_shares,
                "Total Shares After": shares,
                "Cash After Add": balance
            })

        elif signal == -1 and buy_price is not None:  # SELL
            sell_price = trade_close_price
            proceeds = round(shares * sell_price, 2)
            balance = round(balance + proceeds, 2)

            trades.append({
                "Buy Date": buy_date.date(),
                "Buy Price": round(buy_price, 2),
                "Initial Shares": int(start_balance_snapshot // buy_price),
                "Adds": len(adds),
                "Final Shares": shares,
                "Sell Date": date.date(),
                "Sell Price": round(sell_price, 2),
                "Starting Balance": round(start_balance_snapshot, 2),
                "Cash After Trade": balance,
                "Add Details": adds.copy() if adds else []
            })

            buy_price = None
            buy_date = None
            shares = None
            trade_count += 1
            adds = []

    # Handle open position
    if buy_price is not None:
        final_status = "Still in Position"
        last_date = signal_df.index[-1]
        if last_date in trade_prices:
            last_close = trade_prices[last_date]['Close']
            proceeds = round(shares * last_close, 2)
            balance = round(balance + proceeds, 2)

            trades.append({
                "Buy Date": buy_date.date(),
                "Buy Price": round(buy_price, 2),
                "Initial Shares": int(start_balance_snapshot // buy_price),
                "Adds": len(adds),
                "Final Shares": shares,
                "Sell Date": last_date.date(),
                "Sell Price": round(last_close, 2),
                "Starting Balance": round(start_balance_snapshot, 2),
                "Cash After Trade": balance,
                "Note": "Still in position",
                "Add Details": adds.copy() if adds else []
            })
            trade_count += 1

    # Step 6: Prepare Output
    df_output = signal_df[[
        "Open", "High", "Low", "Close", "EMA21", "sell_threshold",
        "low_above_ema", "up_day", "signal", "trade_ticker_price", "max_high_since_buy",
        "pct_above_sell_threshold", "Upper_2ATR", "Upper_3ATR", "Upper_4ATR",
        "pct_high_vs_3ATR", "pct_high_vs_4ATR", "sell_trigger_level", 
        "add_trigger_level", "position_profit_pct", "last_add_profit_pct", "add_check_day"
    ]].round(2)

    percent_gain = round(((balance - starting_balance) / starting_balance) * 100, 2)

    summary_row = {
        "Signal Ticker": signal_ticker,
        "Trade Ticker": trade_ticker,
        "Start Date": pd.to_datetime(start_date).date(),
        "End Date": signal_df.index[-1].date(),
        "Starting Balance": starting_balance,
        "Final Balance": round(balance, 2),
        "Percent Gain": percent_gain,
        "Total Trades": trade_count,
        "Status": final_status
    }

    summaries.append(summary_row)

    # Step 7: Save Excel
    with pd.ExcelWriter(output_file, engine="openpyxl") as writer:
        # Sheet 1: Detailed Trades
        trades_detailed = []
        for i, trade in enumerate(trades, 1):
            buy_date_dt = pd.to_datetime(trade["Buy Date"])
            sell_date_dt = pd.to_datetime(trade["Sell Date"])
            holding_days = (sell_date_dt - buy_date_dt).days
            return_pct = ((trade["Sell Price"] - trade["Buy Price"]) / trade["Buy Price"]) * 100
            
            trades_detailed.append({
                "Trade #": i,
                "Signal Ticker": signal_ticker,
                "Trade Ticker": trade_ticker,
                "Buy Date": trade["Buy Date"],
                "Sell Date": trade["Sell Date"],
                "Holding Days": holding_days,
                "Buy Price": trade["Buy Price"],
                "Sell Price": trade["Sell Price"],
                "Initial Shares": trade["Initial Shares"],
                "# of Adds": trade["Adds"],
                "Final Shares": trade["Final Shares"],
                "Return %": round(return_pct, 2),
                "Profit/Loss": round((trade["Sell Price"] - trade["Buy Price"]) * trade["Initial Shares"], 2),
                "Beginning Balance": trade["Starting Balance"],
                "Balance After": trade["Cash After Trade"],
                "Status": trade.get("Note", "Completed")
            })
        
        trades_df = pd.DataFrame(trades_detailed)
        trades_df.to_excel(writer, sheet_name="Detailed Trades", index=False)
        
        # Sheet 2: Add Details (expanded view of all adds)
        add_details_expanded = []
        for i, trade in enumerate(trades, 1):
            if trade["Add Details"]:
                for add in trade["Add Details"]:
                    add_details_expanded.append({
                        "Trade #": i,
                        "Buy Date": trade["Buy Date"],
                        "Add Date": add["Date"],
                        "Add Price": add["Price"],
                        "Shares Added": add["Shares"],
                        "Total Shares After Add": add["Total Shares After"],
                        "Cash After Add": add["Cash After Add"]
                    })
        
        if add_details_expanded:
            adds_df = pd.DataFrame(add_details_expanded)
            adds_df.to_excel(writer, sheet_name="Add Details", index=False)
        
        # Sheet 3: Add Performance Analysis
        add_performance = []
        for i, trade in enumerate(trades, 1):
            if trade["Adds"] > 0 and trade["Add Details"]:
                # Calculate profit from original shares only
                original_shares = trade["Initial Shares"]
                original_profit = (trade["Sell Price"] - trade["Buy Price"]) * original_shares
                original_return_pct = ((trade["Sell Price"] - trade["Buy Price"]) / trade["Buy Price"]) * 100
                
                # Calculate profit from each add
                total_add_profit = 0
                for add_idx, add in enumerate(trade["Add Details"], 1):
                    add_profit = (trade["Sell Price"] - add["Price"]) * add["Shares"]
                    add_return_pct = ((trade["Sell Price"] - add["Price"]) / add["Price"]) * 100
                    total_add_profit += add_profit
                    
                    add_performance.append({
                        "Trade #": i,
                        "Buy Date": trade["Buy Date"],
                        "Sell Date": trade["Sell Date"],
                        "Holding Days": (pd.to_datetime(trade["Sell Date"]) - pd.to_datetime(trade["Buy Date"])).days,
                        "Component": f"Add #{add_idx}",
                        "Entry Price": add["Price"],
                        "Exit Price": trade["Sell Price"],
                        "Shares": add["Shares"],
                        "Return %": round(add_return_pct, 2),
                        "Profit/Loss": round(add_profit, 2),
                        "Add Date": add["Date"]
                    })
                
                # Add original position as first row
                add_performance.insert(len(add_performance) - trade["Adds"], {
                    "Trade #": i,
                    "Buy Date": trade["Buy Date"],
                    "Sell Date": trade["Sell Date"],
                    "Holding Days": (pd.to_datetime(trade["Sell Date"]) - pd.to_datetime(trade["Buy Date"])).days,
                    "Component": "Original Position",
                    "Entry Price": trade["Buy Price"],
                    "Exit Price": trade["Sell Price"],
                    "Shares": original_shares,
                    "Return %": round(original_return_pct, 2),
                    "Profit/Loss": round(original_profit, 2),
                    "Add Date": None
                })
                
                # Add total row for this trade
                total_profit = original_profit + total_add_profit
                weighted_return = (total_profit / trade["Starting Balance"]) * 100
                
                add_performance.append({
                    "Trade #": i,
                    "Buy Date": trade["Buy Date"],
                    "Sell Date": trade["Sell Date"],
                    "Holding Days": (pd.to_datetime(trade["Sell Date"]) - pd.to_datetime(trade["Buy Date"])).days,
                    "Component": "TOTAL",
                    "Entry Price": None,
                    "Exit Price": None,
                    "Shares": trade["Final Shares"],
                    "Return %": round(weighted_return, 2),
                    "Profit/Loss": round(total_profit, 2),
                    "Add Date": None
                })
        
        if add_performance:
            add_perf_df = pd.DataFrame(add_performance)
            add_perf_df.to_excel(writer, sheet_name="Add Performance Analysis", index=False)
        
        # Sheet 4: Summary
        summary_df = pd.DataFrame([summary_row])
        summary_df.to_excel(writer, sheet_name="Summary", index=False)
        
        # Sheet 5: Strategy Data
        df_output.to_excel(writer, sheet_name="Strategy Data", index=True)

    print(f"\n‚úÖ Strategy complete! Saved to: {output_file}")
    print(f"   Total trades: {trade_count}")
    print(f"   Final balance: ${balance:,.2f}")
    print(f"   Return: {percent_gain:.2f}%")

# Step 8: Save master summary
if len(summaries) > 0:
    summary_df = pd.DataFrame(summaries)
    summary_df.to_excel("output/21eStrategy_with_add_summary.xlsx", index=False)
    print(f"\n{'='*60}")
    print("üìä Master summary saved to: output/21eStrategy_with_add_summary.xlsx")
    print(f"{'='*60}")
else:
    print("\n‚ö†Ô∏è No data to summarize - check your ticker_pairs and date ranges!")